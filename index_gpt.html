<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë™ì „ ì¸ì‹ ì‹œìŠ¤í…œ (AI+ê¸°ë³¸ ëª¨ë“œ)</title>
    
    <!-- OpenCV ë¼ì´ë¸ŒëŸ¬ë¦¬ -->
    <script src="https://docs.opencv.org/4.5.0/opencv.js"></script>

    <style>
        :root {
            --primary: #4285f4;
            --success: #34a853;
            --warning: #fbbc05;
            --error: #ea4335;
            --bg-dark: #1a1a2e;
            --bg-card: #16213e;
            --text: #e6e6e6;
            --text-muted: #a0a0a0;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg-dark);
            color: var(--text);
            font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans KR", sans-serif;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 12px;
        }

        h1 {
            font-size: 18px;
            margin: 8px 0 12px;
        }

        .control-panel {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-bottom: 10px;
        }

        button {
            border: none;
            padding: 10px 12px;
            border-radius: 10px;
            cursor: pointer;
            font-weight: 700;
            background: var(--primary);
            color: white;
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 12px;
        }

        @media (min-width: 860px) {
            .grid {
                grid-template-columns: 1.2fr 0.8fr;
            }
        }

        .card {
            background: var(--bg-card);
            border-radius: 14px;
            padding: 12px;
            box-shadow: 0 8px 20px rgba(0,0,0,0.35);
            border: 1px solid rgba(255,255,255,0.08);
        }

        .video-container {
            position: relative;
            border-radius: 14px;
            overflow: hidden;
            background: #000;
            border: 1px solid rgba(255,255,255,0.12);
        }

        #webcam {
            width: 100%;
            height: auto;
            display: block;
        }

        .overlay {
            position: absolute;
            inset: 0;
            pointer-events: none;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .scan-box {
            width: 300px;
            height: 300px;
            border: 2px dashed rgba(255,255,255,0.65);
            border-radius: 14px;
            box-shadow: 0 0 0 9999px rgba(0,0,0,0.35) inset;
        }

        .badge-row {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .status-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.12);
            background: rgba(0,0,0,0.25);
            font-size: 12px;
            color: var(--text-muted);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: #666;
        }

        .status-loading .status-dot { background: var(--warning); }
        .status-success .status-dot { background: var(--success); }
        .status-warning .status-dot { background: var(--warning); }
        .status-error .status-dot { background: var(--error); }

        .ai-mode-badge {
            padding: 6px 10px;
            border-radius: 999px;
            font-weight: 800;
            font-size: 12px;
            border: 1px solid rgba(255,255,255,0.12);
        }
        .ai-mode-badge.on { background: rgba(52,168,83,0.18); color: #b7f7c9; }
        .ai-mode-badge.off { background: rgba(234,67,53,0.18); color: #ffb4ad; }
        .ai-mode-badge.basic { background: rgba(251,188,5,0.18); color: #ffe08a; }

        .debug-panel {
            margin-top: 10px;
            background: rgba(0,0,0,0.25);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: 12px;
            padding: 10px;
            height: 210px;
            overflow: auto;
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
            font-size: 12px;
        }

        .debug-log { margin: 3px 0; }
        .debug-log.info { color: #9fb3c8; }
        .debug-log.success { color: #b7f7c9; }
        .debug-log.warn { color: #ffe08a; }
        .debug-log.error { color: #ffb4ad; }

        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border-bottom: 1px solid rgba(255,255,255,0.10);
            padding: 10px 8px;
            text-align: left;
            vertical-align: top;
        }
        th {
            font-size: 12px;
            color: var(--text-muted);
        }
        .coin-thumb {
            width: 56px;
            height: 56px;
            object-fit: cover;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.12);
            background: #000;
        }

        .muted {
            color: var(--text-muted);
            font-size: 12px;
            line-height: 1.4;
        }
    </style>
</head>

<body>
<div class="container">
    <h1>ë™ì „ ì¸ì‹ ì‹œìŠ¤í…œ (AI+ê¸°ë³¸ ëª¨ë“œ)</h1>

    <div class="card">
        <div class="control-panel">
            <button id="scan-btn" disabled>ğŸ” ìŠ¤ìº” ì‹œì‘</button>
            <button id="torch-btn" disabled style="background:#34a853;">ğŸ”¦ í”Œë˜ì‹œ</button>
            <button id="macro-btn" disabled style="background:#4285f4;">ğŸ” ì ‘ì‚¬ëª¨ë“œ</button>
            <button onclick="location.reload()" style="background:#6c757d; color:white;">ğŸ”„ ì¬ì‹œì‘</button>
            <button onclick="forceLoadMediaPipe()" style="background:#fbbc05; color:white;">âš¡ AI ì¬ë¡œë“œ</button>
        </div>

        <div class="video-container">
            <video id="webcam" autoplay playsinline muted></video>
            <div class="overlay">
                <div class="scan-box"></div>
            </div>
        </div>

        <div class="badge-row">
            <span class="ai-mode-badge off" id="ai-mode-badge">AI OFF</span>
            <span class="status-badge status-loading" id="opencv-status"><span class="status-dot"></span> OpenCV: ë¡œë”© ì¤‘...</span>
            <span class="status-badge status-loading" id="mediapipe-status"><span class="status-dot"></span> MediaPipe: ë¡œë”© ì¤‘...</span>
            <span class="status-badge status-loading" id="camera-status"><span class="status-dot"></span> Camera: ë¡œë”© ì¤‘...</span>
        </div>

        <div class="debug-panel" id="debug-panel">
            <div class="debug-log info">[ì‹œìŠ¤í…œ] ì´ˆê¸°í™” ì¤‘...</div>
        </div>
    </div>

    <div class="grid">
        <div class="card">
            <div style="display:flex; justify-content:space-between; align-items:center;">
                <div>
                    <div style="font-weight:900; margin-bottom:6px;">ì €ì¥ëœ ì¸ì‹ ê²°ê³¼</div>
                    <div class="muted">IndexedDBì— ì €ì¥ë©ë‹ˆë‹¤.</div>
                </div>
                <span class="status-badge"><span class="status-dot" style="background:#888"></span> <span id="coin-count">0</span>ê±´</span>
            </div>

            <div style="margin-top:12px; overflow:auto; max-height: 520px;">
                <table>
                    <thead>
                    <tr>
                        <th>ì´ë¯¸ì§€</th>
                        <th>ê¸ˆì•¡</th>
                        <th>ë…„ë„</th>
                        <th>ì‹œê°„</th>
                    </tr>
                    </thead>
                    <tbody id="coin-list"></tbody>
                </table>
            </div>
        </div>
    </div>
</div>

<canvas id="temp-canvas" width="300" height="300" style="display:none"></canvas>

<script>
        // ========== ì „ì—­ ë³€ìˆ˜ ==========
        const video = document.getElementById('webcam');
        const debugPanel = document.getElementById('debug-panel');
        const scanBtn = document.getElementById('scan-btn');
        const torchBtn = document.getElementById('torch-btn');
        const macroBtn = document.getElementById('macro-btn');
        const coinList = document.getElementById('coin-list');
        const coinCount = document.getElementById('coin-count');
        const aiModeBadge = document.getElementById('ai-mode-badge');
        const opencvStatus = document.getElementById('opencv-status');
        const mediapipeStatus = document.getElementById('mediapipe-status');
        const cameraStatus = document.getElementById('camera-status');
        
        let textRecognizer = null;
        let db = null;
        let videoTrack = null;
        let isTorchOn = false;
        let isMacroOn = false;
        let isProcessing = false;
        let isAppReady = false;
        let currentAIMode = 'unknown'; // 'ai', 'basic', 'failed'
        

        // ========== MediaPipe ESM ë¡œë” (race ë°©ì§€) ==========
        // vision_bundle.jsë¥¼ <script src>ë¡œ ë¡œë“œí•˜ì§€ ì•Šê³ , ESM(dynamic import)ë¡œ ë¡œë“œí•©ë‹ˆë‹¤.
        let mpVision = null;             // ë¡œë“œëœ MediaPipe Tasks Vision ëª¨ë“ˆ
        let mpWasmBase = null;           // ì„ íƒëœ ë²„ì „ì— ë§ëŠ” wasm base url
        let mpLoadPromise = null;        // ë¡œë”© ì¤‘ì¸ Promise (ì¤‘ë³µ ë¡œë“œ ë°©ì§€)
        let mpLoadToken = 0;             // ìµœì‹  ë¡œë“œ ì‹œë„ í† í° (race ë°©ì§€)
        let mpSource = '';               // ì‹¤ì œ ë¡œë“œì— ì„±ê³µí•œ CDN
        
        async function loadMediaPipeESM({ force = false } = {}) {
            // force=trueë©´ ê¸°ì¡´ ìºì‹œë¥¼ ë¬´ì‹œí•˜ê³  ìƒˆë¡œ ë¡œë“œ ì‹œë„ (ë‹¨, raceëŠ” í† í°ìœ¼ë¡œ ë°©ì§€)
            const myToken = ++mpLoadToken;
            
            if (!force && mpVision) return mpVision;
            if (!force && mpLoadPromise) return mpLoadPromise;
            
            updateStatus(mediapipeStatus, 'loading', 'ESM ë¡œë“œ ì¤‘...');
            log('MediaPipe(Tasks Vision) ESM ë¡œë“œ ì‹œì‘...', 'info');
            
            const candidates = [
                // ì•ˆì •ì ì¸ ìˆœì„œ: jsDelivr â†’ unpkg(?module)
                { src: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14', wasm: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm', label: 'jsdelivr@0.10.14' },
                { src: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3',  wasm: 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm',  label: 'jsdelivr@0.10.3'  },
                { src: 'https://unpkg.com/@mediapipe/tasks-vision@0.10.14?module',     wasm: 'https://unpkg.com/@mediapipe/tasks-vision@0.10.14/wasm',           label: 'unpkg@0.10.14'    },
                { src: 'https://unpkg.com/@mediapipe/tasks-vision@0.10.3?module',      wasm: 'https://unpkg.com/@mediapipe/tasks-vision@0.10.3/wasm',            label: 'unpkg@0.10.3'     }
            ];
            
            mpLoadPromise = (async () => {
                for (const c of candidates) {
                    try {
                        log(`- ì‹œë„: ${c.label}`, 'info');
                        const mod = await import(c.src);
                        
                        // race ë°©ì§€: ë” ìµœì‹  ë¡œë“œê°€ ì‹œì‘ë˜ì—ˆìœ¼ë©´ ê²°ê³¼ íê¸°
                        if (myToken !== mpLoadToken) {
                            log('âš ï¸ ì´ì „ ë¡œë“œ ê²°ê³¼ íê¸° (ìƒˆ ë¡œë“œê°€ ì‹œì‘ë¨)', 'warn');
                            return null;
                        }
                        
                        // ëª¨ë“ˆ í˜•íƒœ ëŒ€ì‘: default export ë˜ëŠ” ëª¨ë“ˆ ìì²´
                        mpVision = mod?.default ?? mod;
                        mpWasmBase = c.wasm;
                        mpSource = c.label;
                        
                        if (!mpVision?.FilesetResolver || !mpVision?.TextRecognizer) {
                            throw new Error('ëª¨ë“ˆì— í•„ìš”í•œ APIê°€ ì—†ìŠµë‹ˆë‹¤ (FilesetResolver/TextRecognizer)');
                        }
                        
                        updateStatus(mediapipeStatus, 'success', `ì‚¬ìš© ê°€ëŠ¥ (${mpSource})`);
                        log(`âœ… MediaPipe ESM ë¡œë“œ ì„±ê³µ: ${mpSource}`, 'success');
                        return mpVision;
                    } catch (e) {
                        log(`  ì‹¤íŒ¨: ${c.label} (${e?.message || e})`, 'warn');
                        // ë‹¤ìŒ í›„ë³´ë¡œ ê³„ì†
                    }
                }
                
                // ëª¨ë‘ ì‹¤íŒ¨
                if (myToken === mpLoadToken) {
                    mpVision = null;
                    mpWasmBase = null;
                    mpSource = '';
                    updateStatus(mediapipeStatus, 'error', 'ESM ë¡œë“œ ì‹¤íŒ¨');
                    updateAIMode('failed');
                    log('âŒ MediaPipe ESM ë¡œë“œ ì‹¤íŒ¨(ëª¨ë“  í›„ë³´)', 'error');
                }
                return null;
            })();
            
            try {
                const v = await mpLoadPromise;
                return v;
            } finally {
                // ì„±ê³µ/ì‹¤íŒ¨ì™€ ê´€ê³„ì—†ì´, í˜„ì¬ í† í°ì˜ ë¡œë“œê°€ ëë‚¬ìœ¼ë©´ promise í•´ì œ
                if (myToken === mpLoadToken) mpLoadPromise = null;
            }
        }

        // ========== ë¡œê¹… ì‹œìŠ¤í…œ ==========
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.createElement('div');
            logElement.className = `debug-log ${type}`;
            logElement.textContent = `[${timestamp}] ${message}`;
            debugPanel.appendChild(logElement);
            debugPanel.scrollTop = debugPanel.scrollHeight;
            console[type === 'error' ? 'error' : type === 'warn' ? 'warn' : 'log'](message);
        }

        // ========== ìƒíƒœ ì—…ë°ì´íŠ¸ ==========
        function updateStatus(element, status, text) {
            element.className = `status-badge status-${status}`;
            element.innerHTML = `<span class="status-dot"></span> ${text}`;
        }

        // ========== AI ëª¨ë“œ ì—…ë°ì´íŠ¸ ==========
        function updateAIMode(mode) {
            currentAIMode = mode;
            switch(mode) {
                case 'ai':
                    aiModeBadge.textContent = 'AI ON';
                    aiModeBadge.className = 'ai-mode-badge on';
                    break;
                case 'basic':
                    aiModeBadge.textContent = 'ê¸°ë³¸ ëª¨ë“œ';
                    aiModeBadge.className = 'ai-mode-badge basic';
                    break;
                case 'failed':
                    aiModeBadge.textContent = 'AI OFF';
                    aiModeBadge.className = 'ai-mode-badge off';
                    break;
            }
        }

        // ========== OpenCV ì´ˆê¸°í™” ==========
        function initOpenCV() {
            return new Promise((resolve) => {
                log('OpenCV ì´ˆê¸°í™” ì¤‘...', 'info');
                updateStatus(opencvStatus, 'loading', 'ë¡œë”© ì¤‘...');
                
                if (typeof cv !== 'undefined' && cv.Mat) {
                    log('âœ… OpenCV ì´ë¯¸ ë¡œë“œë¨', 'success');
                    updateStatus(opencvStatus, 'success', 'ì‚¬ìš© ê°€ëŠ¥');
                    resolve(true);
                    return;
                }
                
                if (typeof cv !== 'undefined') {
                    cv.onRuntimeInitialized = () => {
                        log('âœ… OpenCV ì´ˆê¸°í™” ì™„ë£Œ', 'success');
                        updateStatus(opencvStatus, 'success', 'ì‚¬ìš© ê°€ëŠ¥');
                        resolve(true);
                    };
                } else {
                    log('âš ï¸ OpenCV ë¡œë“œ ì‹¤íŒ¨', 'warn');
                    updateStatus(opencvStatus, 'warning', 'ë¡œë“œ ì‹¤íŒ¨');
                    resolve(false);
                }
            });
        }

        // ========== MediaPipe ì´ˆê¸°í™” (ESM ë¡œë” ì‚¬ìš©) ==========
        async function initMediaPipe() {
            log('MediaPipe ë¼ì´ë¸ŒëŸ¬ë¦¬(ESM) í™•ì¸/ë¡œë“œ ì¤‘...', 'info');
            
            // ì´ë¯¸ ë¡œë“œëœ ê²½ìš°
            if (mpVision) {
                updateStatus(mediapipeStatus, 'success', `ì‚¬ìš© ê°€ëŠ¥ (${mpSource || 'cached'})`);
                log('âœ… MediaPipe ì´ë¯¸ ë¡œë“œë¨', 'success');
                return true;
            }
            
            const v = await loadMediaPipeESM({ force: false });
            if (v) {
                updateStatus(mediapipeStatus, 'success', `ì‚¬ìš© ê°€ëŠ¥ (${mpSource})`);
                return true;
            }
            
            // ì‹¤íŒ¨
            updateStatus(mediapipeStatus, 'warning', 'ë¡œë“œ ì‹¤íŒ¨');
            updateAIMode('failed');
            return false;
        }

        // ========== MediaPipe ê°•ì œ ë¡œë“œ (race-safe ESM) ==========
        async function forceLoadMediaPipe() {
            // UI/ê¸°ëŠ¥ ìœ ì§€: ë²„íŠ¼ í´ë¦­ ì‹œ ì•ˆì „í•˜ê²Œ ì¬ë¡œë“œ
            try {
                log('âš¡ AI ì¬ë¡œë“œ ìš”ì²­', 'warn');
                
                // ì¬ë¡œë“œ ì¤‘ UI ì ê¸ˆ
                const reloadBtn = document.querySelector('button[onclick="forceLoadMediaPipe()"]');
                if (reloadBtn) {
                    reloadBtn.disabled = true;
                    reloadBtn.textContent = 'â³ AI ì¬ë¡œë“œ ì¤‘...';
                }
                
                updateStatus(mediapipeStatus, 'loading', 'ì¬ë¡œë“œ ì¤‘...');
                updateAIMode('basic');
                
                // 1) MediaPipe ëª¨ë“ˆ ê°•ì œ ì¬ë¡œë“œ (race ë°©ì§€ í† í° ì‚¬ìš©)
                const v = await loadMediaPipeESM({ force: true });
                if (!v) {
                    throw new Error('MediaPipe ESM ë¡œë“œ ì‹¤íŒ¨');
                }
                
                // 2) AI ëª¨ë¸ ì¬ì´ˆê¸°í™”
                log('AI ëª¨ë¸ ì¬ì´ˆê¸°í™” ì‹œì‘...', 'info');
                const aiLoaded = await initAIModel();
                
                if (aiLoaded) {
                    log('âœ… AI ëª¨ë¸ ì¬ì´ˆê¸°í™” ì™„ë£Œ!', 'success');
                    updateAIMode('ai');
                    alert('âœ… AI ê¸°ëŠ¥ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤!');
                } else {
                    log('âš ï¸ AI ëª¨ë¸ ì¬ì´ˆê¸°í™” ì‹¤íŒ¨ (ê¸°ë³¸ ëª¨ë“œë¡œ ì „í™˜)', 'warn');
                    updateAIMode('basic');
                    alert('âš ï¸ AI ëª¨ë¸ ì´ˆê¸°í™”ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\në„¤íŠ¸ì›Œí¬/ë¸Œë¼ìš°ì €/ê¸°ê¸° GPU ì§€ì›ì„ í™•ì¸í•´ì£¼ì„¸ìš”.');
                }
                
                return aiLoaded;
                
            } catch (error) {
                log(`âŒ AI ì¬ë¡œë“œ ì‹¤íŒ¨: ${error.message}`, 'error');
                updateStatus(mediapipeStatus, 'error', 'ì¬ë¡œë“œ ì‹¤íŒ¨');
                updateAIMode('failed');
                alert('âš ï¸ AI ì¬ë¡œë“œì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤.\nì½˜ì†”(Network)ì—ì„œ wasm/tflite ìš”ì²­ì´ ë§‰í˜”ëŠ”ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.');
                return false;
                
            } finally {
                const reloadBtn = document.querySelector('button[onclick="forceLoadMediaPipe()"]');
                if (reloadBtn) {
                    reloadBtn.disabled = false;
                    reloadBtn.textContent = 'âš¡ AI ì¬ë¡œë“œ';
                }
            }
        }

        // ========== IndexedDB ì´ˆê¸°í™” ==========
        function initDB() {
            return new Promise((resolve, reject) => {
                log('IndexedDB ì´ˆê¸°í™” ì¤‘...', 'info');
                
                const request = indexedDB.open('CoinDB', 1);
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    if (!db.objectStoreNames.contains('coins')) {
                        db.createObjectStore('coins', { keyPath: 'id', autoIncrement: true });
                    }
                };
                
                request.onsuccess = (event) => {
                    db = event.target.result;
                    log('âœ… IndexedDB ì´ˆê¸°í™” ì™„ë£Œ', 'success');
                    resolve(true);
                };
                
                request.onerror = () => {
                    log('âŒ IndexedDB ì´ˆê¸°í™” ì‹¤íŒ¨', 'error');
                    reject(request.error);
                };
            });
        }

        // ========== ì¹´ë©”ë¼ ì´ˆê¸°í™” ==========
        async function initCamera() {
            try {
                log('ì¹´ë©”ë¼ ì´ˆê¸°í™” ì¤‘...', 'info');
                updateStatus(cameraStatus, 'loading', 'ì´ˆê¸°í™” ì¤‘...');
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        facingMode: 'environment',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    }
                });
                
                video.srcObject = stream;
                videoTrack = stream.getVideoTracks()[0];
                
                // í† ì¹˜/ì ‘ì‚¬ ì§€ì› í™•ì¸
                const capabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
                
                if (capabilities.torch) {
                    torchBtn.disabled = false;
                    log('âœ… í”Œë˜ì‹œ ê¸°ëŠ¥ ì§€ì›', 'success');
                } else {
                    log('â„¹ï¸ í”Œë˜ì‹œ ë¯¸ì§€ì›', 'info');
                }
                
                if (capabilities.focusMode && capabilities.focusMode.includes('manual')) {
                    macroBtn.disabled = false;
                    log('âœ… ì ‘ì‚¬ ëª¨ë“œ ì§€ì›', 'success');
                } else {
                    log('â„¹ï¸ ì ‘ì‚¬ ëª¨ë“œ ë¯¸ì§€ì›', 'info');
                }
                
                updateStatus(cameraStatus, 'success', 'ì‚¬ìš© ê°€ëŠ¥');
                log('âœ… ì¹´ë©”ë¼ ì´ˆê¸°í™” ì™„ë£Œ', 'success');
                return true;
                
            } catch (error) {
                log(`âŒ ì¹´ë©”ë¼ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
                updateStatus(cameraStatus, 'error', 'ì‹¤íŒ¨');
                return false;
            }
        }

        // ========== AI ëª¨ë¸ ì´ˆê¸°í™” ==========
        async function initAIModel() {
            try {
                log('AI ëª¨ë¸ ì´ˆê¸°í™” ì¤‘...', 'info');
                
                const vision = mpVision;
                if (!vision) {
                    log('MediaPipe ëª¨ë“ˆì´ ë¡œë“œë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤', 'warn');
                    updateAIMode('basic');
                    return false;
                }
                if (!mpWasmBase) {
                    mpWasmBase = "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm";
                }
                
                const filesetResolver = await vision.FilesetResolver.forVisionTasks(
                    mpWasmBase
                );
                
                textRecognizer = await vision.TextRecognizer.createFromOptions(
                    filesetResolver,
                    {
                        baseOptions: {
                            modelAssetPath: "https://storage.googleapis.com/mediapipe-models/text_recognizer/text_recognizer_thin/float32/1/text_recognizer_thin.tflite",
                            delegate: "GPU"
                        },
                        runningMode: "IMAGE"
                    }
                );
                
                log('âœ… AI ëª¨ë¸ ì´ˆê¸°í™” ì™„ë£Œ!', 'success');
                updateAIMode('ai');
                return true;
                
            } catch (error) {
                log(`âŒ AI ëª¨ë¸ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
                updateAIMode('basic');
                textRecognizer = null;
                return false;
            }
        }

        // ========== ë™ì „ ëª©ë¡ ë Œë”ë§ ==========
        async function renderTable() {
            if (!db) return;
            
            const tx = db.transaction('coins', 'readonly');
            const store = tx.objectStore('coins');
            const request = store.getAll();
            
            request.onsuccess = (event) => {
                const coins = event.target.result || [];
                coinCount.textContent = coins.length.toString();
                
                // ìµœì‹ ìˆœ ì •ë ¬
                coins.sort((a, b) => new Date(b.time) - new Date(a.time));
                
                coinList.innerHTML = coins.map(c => {
                    const url = URL.createObjectURL(c.image);
                    const time = new Date(c.time).toLocaleString();
                    return `
                        <tr>
                            <td><img src="${url}" class="coin-thumb" onload="URL.revokeObjectURL('${url}')"></td>
                            <td>${c.amount || 'ë¯¸í™•ì¸'}ì›</td>
                            <td><b>${c.year || 'ë¯¸í™•ì¸'}ë…„</b></td>
                            <td>${time}</td>
                        </tr>
                    `;
                }).join('');
            };
        }

        // ========== ìŠ¤ìº” (AI ìš°ì„ , ì‹¤íŒ¨ ì‹œ ê¸°ë³¸) ==========
        async function scanCoin() {
            if (isProcessing) return;
            isProcessing = true;
            scanBtn.disabled = true;
            scanBtn.textContent = 'â³ ì²˜ë¦¬ ì¤‘...';
            
            try {
                log('ìŠ¤ìº” ì‹œì‘...', 'info');
                const canvas = document.getElementById('temp-canvas');
                const ctx = canvas.getContext('2d');
                
                const size = 300;
                canvas.width = size;
                canvas.height = size;
                
                const vw = video.videoWidth;
                const vh = video.videoHeight;
                const sx = Math.max(0, Math.floor((vw - size) / 2));
                const sy = Math.max(0, Math.floor((vh - size) / 2));
                
                ctx.drawImage(video, sx, sy, size, size, 0, 0, size, size);

                let text = '';
                if (textRecognizer) {
                    try {
                        log('AI OCR ì¸ì‹ ì¤‘...', 'info');
                        const result = await textRecognizer.recognize(canvas);
                        const paragraphs = result?.paragraphs || [];
                        text = paragraphs.map(p => p.text).join(' ').trim();
                        log(`AI OCR ê²°ê³¼: "${text || 'ê¸€ì ì—†ìŒ'}"`, text ? 'success' : 'warn');
                    } catch (e) {
                        log(`AI OCR ì‹¤íŒ¨: ${e?.message || e}`, 'warn');
                    }
                } else {
                    log('AI ë¹„í™œì„± ìƒíƒœ â†’ ê¸°ë³¸ ëª¨ë“œë¡œ ì§„í–‰', 'warn');
                }

                // ìˆ«ì íŒŒì‹±
                const numbers = (text.match(/\d+/g) || []).map(n => n.trim());
                let year = 'ë¯¸í™•ì¸';
                let amount = 'ë¯¸í™•ì¸';
                
                for (const n of numbers) {
                    if (n.length === 4 && (n.startsWith('19') || n.startsWith('20'))) year = n;
                    if (['10','50','100','500'].includes(n)) amount = n;
                }

                const blob = await new Promise(resolve => canvas.toBlob(resolve, 'image/webp', 0.92));

                const tx = db.transaction('coins', 'readwrite');
                tx.objectStore('coins').add({ year, amount, text, image: blob, time: new Date().toISOString() });
                
                tx.oncomplete = async () => {
                    log(`ğŸ’¾ ì €ì¥ë¨: ${year}ë…„ ${amount}ì›`, 'success');
                    await renderTable();
                };
                
            } catch (error) {
                log(`âŒ ìŠ¤ìº” ì‹¤íŒ¨: ${error.message}`, 'error');
            } finally {
                isProcessing = false;
                scanBtn.disabled = false;
                scanBtn.textContent = 'ğŸ” ìŠ¤ìº” ì‹œì‘';
            }
        }

        // ========== í† ì¹˜ í† ê¸€ ==========
        async function toggleTorch() {
            if (!videoTrack) return;
            const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
            if (!caps.torch) {
                log('í† ì¹˜ ë¯¸ì§€ì›', 'warn');
                return;
            }
            try {
                isTorchOn = !isTorchOn;
                await videoTrack.applyConstraints({ advanced: [{ torch: isTorchOn }] });
                log(`í”Œë˜ì‹œ ${isTorchOn ? 'ON' : 'OFF'}`, 'info');
            } catch (e) {
                log(`í† ì¹˜ ì„¤ì • ì‹¤íŒ¨: ${e?.message || e}`, 'warn');
            }
        }

        // ========== ì ‘ì‚¬ í† ê¸€ ==========
        async function toggleMacro() {
            if (!videoTrack) return;
            const caps = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
            const supportsManual = Array.isArray(caps.focusMode) && caps.focusMode.includes('manual');
            if (!supportsManual) {
                log('ì ‘ì‚¬ ë¯¸ì§€ì›', 'warn');
                return;
            }
            try {
                isMacroOn = !isMacroOn;
                const minFD = (caps.focusDistance && typeof caps.focusDistance.min === 'number') ? caps.focusDistance.min : 0;

                const advanced = isMacroOn
                    ? [{ focusMode: 'manual', focusDistance: minFD }]
                    : [{ focusMode: 'continuous' }];

                await videoTrack.applyConstraints({ advanced });
                log(`ì ‘ì‚¬ëª¨ë“œ ${isMacroOn ? 'ON' : 'OFF'}`, 'info');
            } catch (e) {
                log(`ì ‘ì‚¬ ì„¤ì • ì‹¤íŒ¨: ${e?.message || e}`, 'warn');
            }
        }

        // ========== ì•± ì´ˆê¸°í™” ==========
        async function initApp() {
            try {
                log('=== ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì‹œì‘ ===', 'info');
                
                // 1. OpenCV ì´ˆê¸°í™”
                await initOpenCV();
                
                // 2. MediaPipe ì´ˆê¸°í™” (ESM)
                const mediapipeLoaded = await initMediaPipe();
                
                // 3. AI ëª¨ë¸ ì´ˆê¸°í™” (MediaPipe ë¡œë“œëœ ê²½ìš°)
                let aiLoaded = false;
                if (mediapipeLoaded) {
                    aiLoaded = await initAIModel();
                } else {
                    updateAIMode('failed');
                }
                
                // 4. DB ì´ˆê¸°í™”
                await initDB();
                await renderTable();
                
                // 5. ì¹´ë©”ë¼ ì´ˆê¸°í™”
                const cameraLoaded = await initCamera();
                if (!cameraLoaded) {
                    throw new Error('ì¹´ë©”ë¼ ì´ˆê¸°í™” ì‹¤íŒ¨');
                }
                
                // ë²„íŠ¼ ì—°ê²°
                scanBtn.onclick = scanCoin;
                torchBtn.onclick = toggleTorch;
                macroBtn.onclick = toggleMacro;

                scanBtn.disabled = false;
                
                isAppReady = true;
                log('âœ… ì• í”Œë¦¬ì¼€ì´ì…˜ ì´ˆê¸°í™” ì™„ë£Œ!', 'success');
                log(`ğŸ“Š ìƒíƒœ: AI=${aiLoaded ? 'í™œì„±' : 'ë¹„í™œì„±'}, ì¹´ë©”ë¼=í™œì„±`, 'info');
                
                if (!aiLoaded) {
                    log('ğŸ’¡ AI ê¸°ëŠ¥ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤. [AI ì¬ë¡œë“œ] ë²„íŠ¼ì„ í´ë¦­í•˜ê±°ë‚˜ ê¸°ë³¸ ëª¨ë“œë¡œ ì‚¬ìš©í•´ì£¼ì„¸ìš”.', 'warn');
                }
                
            } catch (error) {
                log(`âŒ ì´ˆê¸°í™” ì‹¤íŒ¨: ${error.message}`, 'error');
                
                scanBtn.disabled = false;
                scanBtn.innerHTML = 'ğŸ”„ ì¬ì‹œë„';
                scanBtn.onclick = () => location.reload();
            }
        }

        // ========== ì‹œì‘ ==========
        document.addEventListener('DOMContentLoaded', () => {
            log('í˜ì´ì§€ ë¡œë“œ ì™„ë£Œ', 'info');
            initApp();
        });
</script>
</body>
</html>
